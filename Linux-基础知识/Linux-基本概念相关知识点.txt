四、Linux的文本流
	1、文件流的定义：文件可以使用统一的接口（统一的输入输出方式）之间传输（流动）。
	2、标准输入、标准输出、标准错误、重新定向
		2.1、前两者是常用的指令，如ls,mkdir,cd等
		2.2、重新定向：改变文件流的方向。例如，ls会默认打印当前路径下所有文件于终端（显示器）。那么ls > a.txt即改变打印的方向
				可打印到a.txt文档中。
				同理，cat < a.txt > b.txt把a.txt的数据输入到cat中，然后输出到b.txt文档中，假如没有>重定向符号，则会默认输出到终端
				同理，echo dandelion > a.txt 把dandelion输入到a.txt文件中
		2.3、标准错误：即统一的错误类型，例如cd dir0，假如没有此文件夹，则会提示找不到路径。而不会提示别的东西。这便是标准的错误。
		2.4、标准错误重定向：先看cd dir0 >& a.txt。假如没有dir0文件夹，则把显示的错误输出到a.txt文件中。
	3、管道FIFO：讲一个命令的输出导向另一个命令的输入。可以形象的理解为一根管子，连通两个部分，可传输数据
		3.1、cat < a.txt | wc
			wc：Word count统计文本中的行，词，字符的总数。
			同理，很多命令都可以使用管道把彼此连接起来
			
五、进程
	5.1、进程的概念知识
		5.1.1、进程是程序的具体实现。
		5.1.2、kernel启动的时候会创建一个init进程，也是第一个进程。其他的进程都是在init的基础上fork（新进程复制老进程得到）
				由此可形成一个进程树，init进程为根。
		5.1.3、线程是一种特殊的进程。多线程之间可以共享IO口。所以，进程是Linux程序实现的唯一方式。
	5.2、进程的运作方式
		5.2.1、进程的组成（内部组成的空间划分）
			1、Text：存放指令instruction code
			2、global data：存放全局变量
			3、heap（堆）：存放动态变量，malloc时创建的空间即在此
			4、stack（栈）：存放局部变量。调用函数的时候，里面存在的局部变量所需要的空间即在此。
			5、unuser area（未使用空间）：此部分大小有限，当进程被创建的时候即确定了。
		5.2.2、进程的工作
			1、栈是以帧为单位。当调用一个子函数的时候，此时控制权在后者中，它会在栈顶开辟一帧空间用于存放此函数涉及到的局部变量。占用的空间是unuser area。同理，子函数中又调用
				子函数的话，控制权则移交到了新的子函数中，它会又开辟一帧，进行相同的操作。但是，它只能调用本帧的数据。不能调用上一帧的数据，只有当此部分处理完了，控制权移交到上一个函数。它才能访问此帧数据。
				这也符合栈的先进后出原则。
			2、当每次malloc时也会在unuser area中开辟一块空间，需要使用free才能释放，否则一直会存在。
			3、由于unuser area的空间有限，所以容易超出它的最大范围。即溢出。
		5.2.3、两点总结：
			1、进程作用于整个程序。每次调用函数时，会在栈中开辟一帧空间用于数据存放。
			2、text于global data在进程被创建的时候，他们的大小即确定了。
			3、heap与stack在进程的运行过程中为动态大小。但是，stack、heap、unuser area三者空间之和为固定不变。
		
		5.2.4、进程的组成（附件信息）
			1、存储位置：内核空间中，使用task_struct结构体存储。
			2、信息值：包括PID，PPID，PGID。用来说明进程的身份，进程关系，其他统计值。相当于门牌号的功能，不需要进入内部就知道
				进程的功能，大概信息之类的。例如，软件部的OBC组的第三位同事。通过此标签就能知道此同事大概是做啥工作。
		5.2.5、深入了解
			1、fork指令：fork指令复制了老进程，然后改掉附件信息，生成了属于新进程自己的信息，例如，PID为新的，PPID为复制之前的PID。但是内部组成部分没有改动。
							所以，只能通过附件信息区分两者。
			2、exec指令；执行exec后会清除内部信息，如text，global data，heap，stack。根据新的程序文件新建内部信息。
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			
				