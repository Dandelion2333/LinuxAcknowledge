四、Linux的文本流
	1、文件流的定义：文件可以使用统一的接口（统一的输入输出方式）之间传输（流动）。
	2、标准输入、标准输出、标准错误、重新定向
		2.1、前两者是常用的指令，如ls,mkdir,cd等
		2.2、重新定向：改变文件流的方向。例如，ls会默认打印当前路径下所有文件于终端（显示器）。那么ls > a.txt即改变打印的方向
				可打印到a.txt文档中。
				同理，cat < a.txt > b.txt把a.txt的数据输入到cat中，然后输出到b.txt文档中，假如没有>重定向符号，则会默认输出到终端
				同理，echo dandelion > a.txt 把dandelion输入到a.txt文件中
		2.3、标准错误：即统一的错误类型，例如cd dir0，假如没有此文件夹，则会提示找不到路径。而不会提示别的东西。这便是标准的错误。
		2.4、标准错误重定向：先看cd dir0 >& a.txt。假如没有dir0文件夹，则把显示的错误输出到a.txt文件中。
	3、管道FIFO：讲一个命令的输出导向另一个命令的输入。可以形象的理解为一根管子，连通两个部分，可传输数据
		3.1、cat < a.txt | wc
			wc：Word count统计文本中的行，词，字符的总数。
			同理，很多命令都可以使用管道把彼此连接起来
			
五、进程
	5.1、进程的概念知识
		5.1.1、进程是程序的具体实现。
		5.1.2、kernel启动的时候会创建一个init进程，也是第一个进程。其他的进程都是在init的基础上fork（新进程复制老进程得到）
				由此可形成一个进程树，init进程为根。
		5.1.3、线程是一种特殊的进程。多线程之间可以共享IO口。所以，进程是Linux程序实现的唯一方式。
	5.2、进程的运作方式
		5.2.1、进程的组成（内部组成的空间划分）
			1、Text：存放指令instruction code
			2、global data：存放全局变量
			3、heap（堆）：存放动态变量，malloc时创建的空间即在此
			4、stack（栈）：存放局部变量。调用函数的时候，里面存在的局部变量所需要的空间即在此。
			5、unuser area（未使用空间）：此部分大小有限，当进程被创建的时候即确定了。
		5.2.2、进程的工作
			1、栈是以帧为单位。当调用一个子函数的时候，此时控制权在后者中，它会在栈顶开辟一帧空间用于存放此函数涉及到的局部变量。占用的空间是unuser area。同理，子函数中又调用
				子函数的话，控制权则移交到了新的子函数中，它会又开辟一帧，进行相同的操作。但是，它只能调用本帧的数据。不能调用上一帧的数据，只有当此部分处理完了，控制权移交到上一个函数。它才能访问此帧数据。
				这也符合栈的先进后出原则。
			2、当每次malloc时也会在unuser area中开辟一块空间，需要使用free才能释放，否则一直会存在。
			3、由于unuser area的空间有限，所以容易超出它的最大范围。即溢出。
		5.2.3、两点总结：
			1、进程作用于整个程序。每次调用函数时，会在栈中开辟一帧空间用于数据存放。
			2、text于global data在进程被创建的时候，他们的大小即确定了。
			3、heap与stack在进程的运行过程中为动态大小。但是，stack、heap、unuser area三者空间之和为固定不变。
		
		5.2.4、进程的组成（附件信息）
			1、存储位置：内核空间中，使用task_struct结构体存储。
			2、信息值：包括PID，PPID，PGID。用来说明进程的身份，进程关系，其他统计值。相当于门牌号的功能，不需要进入内部就知道
				进程的功能，大概信息之类的。例如，软件部的OBC组的第三位同事。通过此标签就能知道此同事大概是做啥工作。
		5.2.5、深入了解
			1、fork指令：fork指令复制了老进程，然后改掉附件信息，生成了属于新进程自己的信息，例如，PID为新的，PPID为复制之前的PID。但是内部组成部分没有改动。
							所以，只能通过附件信息区分两者。
			2、exec指令；执行exec后会清除内部信息，如text，global data，heap，stack。根据新的程序文件新建内部信息。
	5.3进程与线程的关系
		5.3.1、举个例子，打开QQ，是开了一个进程。QQ里面需要输入文字，是开了一个线程。然后开个语音也是使用线程。也就是说，线程是用来完成里面一个一个的任务。而进程是管控整个程序。
		5.3.2、每开一个线程，就会创建一个栈区，用于存放局部变量数据。所以，当多线程运行时会有多个栈区。
			
六、Linux并发与同步

七、Linux调度器
	7.1、进程的状态
		7.1.1、执行状态：顾名思义，进程被CPU执行的状态
		7.1.2、就绪状态：顾名思义，处在就绪中的状态，一旦有机会即被CPU执行。已经获取了除CPU之外的所有条件。如进程空间，网络连接。
		7.1.3、阻塞状态：顾名思义，由于进程等待某个状态而无法执行时，即放弃CPU的使用权利，进入阻塞状态。
		7.1.4、当进程被创建的时候就会进入就绪状态。调度器的功能是把就绪状态的进程变成执行状态。二是把执行状态的进程变成就绪状态。值得注意的是，只有抢占式调度器拥有两个功能。普通的调度器只能把就绪状态的进程切到执行，不能反向操作。
				那么，阻塞状态呢？调度器可以操作吗？待查证。
				
	7.2、进程的优先级
		7.2.1、Linux系统中，进程一共有0-139个优先级。数字越小，优先级越高。
		7.2.2、进程分两种
			实时进程：能够实时响应的进程，响应级别高，所以优先级必须高，它在0-99。
			普通进程：普通用户创建的进程，响应级别次于实时进程，所以它在100-139。
		7.2.3、动态进程，当进程被创建后为默认优先级（120）。计算为动态进程的公式如下：（备注：当进程执行时，默认进程会变成静态进程）
			动态进程 = 静态进程 - bonus + 5
			bonus的功能是调节作用，假如此进程经常被使用，那么系统会把bonus数值大于5，或者更大，以便能够更快的响应此进程。同理不常用则缩小。
		7.2.4、进程优先级设定
			nice -n -20 ./app
			例如，默认进程优先级为120，那么减20即为100。值得注意的是，普通进程最多只能设置为100-139之内。超出部分按照峰值处理。
	
	7.3、O(n)与O(1)调度器
		7.3.1、调度器的工作原理
			1、n表示进程数目，O表示时间复杂度。意味着，当进程越多的时候，时间复杂度越高。同理，1表示常数，无论进程数目多少，时间复杂度都为常数
				Linux内核2.6版本之前使用O(n)调度器。由于是历史事件了，所以不做深入探究。Linux内核2.6之后使用O(1)调度器。
			2、O(n)调度器的工作原理为：CPU每次都会遍历就绪状态的进程，选择并执行优先级最高的进程，执行的时长为一个时间片长度。
				缺陷：这种操作模式的弊端很明显，当非常多的任务待处理时，每次遍历的时间非常长，效率低下。并且，会产生饥饿进程，即优先级高的进程总是占据CPU资源，导致优先级低的进程没有机会获取CPU的资源。
			3、O(1)调度器为了解决O(n)的问题。引入了280个队列。分别为活跃队列140个，过期队列140个。分别对应进程优先级的140个级别。
				工作原理：调度器从活跃队列中按照优先级高低的方式选择执行进程，执行时长最大为一个时间片（假如，进程的时长未超过时间片就结束了。那么，它也会被加入到过期队列中），然后被加入到过期队列中。
				假如，同一优先级有多个进程，那么按照概率选择执行其中一个进程。然后再用同样的方式执行剩下的进程。
			4、O(1)调度器执行时长：
				优先级为120以下的进程时间片为：
					(140–priority)×20毫秒
				优先级120及以上的进程时间片为：
					(140–priority)×5 毫秒
				由公式可知，120以下的进程会占据大量的执行时间，这对120以上的进程不友好。也容易产生饥饿进程。所以，此调度器还不够完美
	
	7.4、完全公平调度器（completely fair scheduler）
		1、调度器原理：引入虚拟执行时的概念，每次CPU执行某个进程都会记录一次进程使用的时长。每次调度之前会选择进程调度时长最短的进程，而不是像O(1)选择优先级高的进程。使用红黑树取代O(1)调度器的280个队列。
			红黑树可以高效的找到虚拟运行最小的进程。
		2、优先级的作用，设置优先级高的进程时间片因子更长。例如，普通的一个运行时为250毫秒，优先级高的进程一个运行时设置为300毫秒，优先级低的设置为200毫秒。所以，优先级高的进程会占用更多的CPU资源。
			通过此方式，可以把CPU资源更好的分配给进程。
		
	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			
				